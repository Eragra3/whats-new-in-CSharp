<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/dracula.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU"
    crossorigin="anonymous">
</head>

<body>
  <div class="reveal">
    <div class="slides">

      <section>
        <h2>Nowości w języku
          <span class="fragment strike">Cool</span>
          <span class="fragment fade-in">C#</span>
        </h2>
        <p class="fragment fade-in-and-out">C-like Object Oriented Language</p>

        <h3>
          Daniel Bider
        </h3>

        <aside class="notes">
          <p>Biblioteka napisana w Simple Managed C (SMC), potem sportowana do C#</p>>
        </aside>
      </section>

      <section>
        <h2>Krótka historia C#</h2>
        <span class="fragment fade-in">Rok powstania: </span>
        <span class="fragment fade-in">1999</span>
        <br \>
        <span class="fragment fade-in">Twórca: </span>
        <span class="fragment fade-in">Anders Hejlsberg</span>

        <aside class="notes">
          <p>Java - 1995, Ryan Gosling</p>
          <p>C++ - 1985, Bjarne Stroustrup</p>
        </aside>
      </section>

      <section>
        <h2>Wersje C#</h2>

        <div class="fragment fade-in">
          <h3>C# 1.0 (1.1, 1.2)</h3>
          <p class="fragment fade-in">nic ciekawego</p>
        </div>

        <aside class="notes">
          <p>brak generyków, nie ma LINQ, kalka Javy (twórcy twierdzą, że nie kalka)</p>
        </aside>
      </section>

      <section>
        <h3>C# 2.0</h3>
        <ul class="fragment fade-in">
          <li>Generics</li>
          <li>Nullable types</li>
          <li>Partial types</li>
          <li>Static classes</li>
          <li>Variance</li>
        </ul>
      </section>

      <section>
        <h3>C# 3.0</h3>
        <ul class="fragment fade-in">
          <li><i>Var</i> keyword</li>
          <li>Lambdas</li>
          <li>Object and collection initializers</li>
          <li>Auto-properties</li>
          <li>Extension methods</li>
          <li>Partial methods</li>
        </ul>
      </section>

      <section>
        <h3>C# 4.0</h3>
        <ul class="fragment fade-in">
          <li>Dynamic binding...</li>
          <li>Generic variance</li>
        </ul>
      </section>

      <section>
        <h3>C# 5.0</h3>
        <ul class="fragment fade-in">
          <li>Async</li>
        </ul>
      </section>

      <section>
        <h3>C# 6.0</h3>
        <ul class="fragment fade-in">
          <li><b>Compiler-as-a-service (Roslyn)</b></li>
          <li>Auto property initializers</li>
          <li>String interpolation</li>
          <li>Nameof operator</li>
          <li>Exception filters</li>
          <li>Null propagator</li>
          <li>Dictionary initializer</li>
        </ul>

        <aside class="notes">
          <p>C#6 <a href="https://github.com/dotnet/roslyn/wiki/Languages-features-in-C%23-6-and-VB-14"></a></p>
        </aside>
      </section>

      <section>
        <h1>C# 7.0</h1>
      </section>
      <section>

        <section>
          <h2>Inline out variables</h2>

          <pre><code class="cs" data-trim data-noescape>
            string numberString = "42";

            <span class="fragment highlight-mark" data-fragment-index="1">int number;</span>
            if (int.TryParse(numberString, <span class="fragment highlight-mark" data-fragment-index="1">out number</span>))
            {
                int nextNumber = number + 1;
            (...)
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>

            <pre><code class="cs" data-trim data-noescape>
              string numberString = "42";

              if (int.TryParse(numberString, <span class="fragment highlight-mark">out int number</span>))
              {
                  int nextNumber = number + 1;
              (...)
            </code></pre>
          </span>
        </section>

        <section>
          <h2>IL</h2>
          <pre><code class="cs" data-trim data-noescape>
            IL_0007: ldloc.0
            IL_0008: ldloca.s 1
            IL_000a: call bool [mscorlib]System.Int32::TryParse(string, int32&)
            IL_000f: stloc.2
            // sequence point: hidden
            IL_0010: ldloc.2
            IL_0011: brfalse.s IL_0031
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>
            <pre><code class="cs" data-trim data-noescape>
              IL_0007: ldloc.0
              IL_0008: ldloca.s 1
              IL_000a: call bool [mscorlib]System.Int32::TryParse(string, int32&)
              IL_000f: stloc.2
              // sequence point: hidden
              IL_0010: ldloc.2
              IL_0011: brfalse.s IL_0031
            </code></pre>
          </span>

          <aside class="notes">
            <table>
              <thead>
                <th>operation</th>
                <th>description</th>
              </thead>
              <tbody>
                <tr>
                  <td>ldloc.0</td>
                  <td>Load local variable 0 onto stack.</td>
                </tr>
                <tr>
                  <td>ldloca.s &lt;uint8 (indx)&gt;</td>
                  <td>Load address of local variable with index indx, short form.</td>
                </tr>
              </tbody>
            </table>
          </aside>
        </section>

        <section>
          <h2>Uwaga na zasięg zmiennej!</h2>

          <pre><code class="cs" data-trim data-noescape>
            static void Main(string[] args)
            {
                string numberString = "42";
                for (int i = 0; i < 100; i++)<span class="fragment highlight-mark" data-fragment-index="2">
                {
                    if (int.TryParse(numberString, <span class="fragment highlight-mark" data-fragment-index="1">out int number</span>))
                    {
                        int nextNumber = number + 1;
                        Console.WriteLine($"Next person number is {nextNumber}");
                    }
                    else
                    {
                        Console.WriteLine("Invalid number");
                    }
                }</span>
            }
            </code></pre>

          <aside class="notes">
            Przykład
          </aside>
        </section>
      </section>

      <section>
        <section>
          <h2>Krotki (tuples)</h2>

          <pre><code class="cs" data-trim data-noescape>
            var t1 = new Tuple&lt;int, double, int&gt;(-3, 10.0, 4);
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>

            <pre><code class="cs" data-trim data-noescape>
              var t1 = (-3, 10.0, 4);
            </code></pre>
          </span>
        </section>
        <section>
          <h2>Nazwane krotki</h2>

          <pre><code class="cs" data-trim data-noescape>
            var t1 = (min: -3, avg: 10.0, max: 4);
            Console.WriteLine(t1.min);
          </code></pre>
        </section>

        <section>
          <h2>Dekonstrukcja</h2>

          <pre><code class="cs" data-trim data-noescape>
            var minAvgMax = (min: -3, avg: 10.0, max: 4);
            var (min, avg, max) = minAvgMax;
            Console.WriteLine(min);
          </code></pre>

          <aside class="notes">
            Przykład
          </aside>
        </section>
      </section>

      <section>
        <section>
          <h2>Pattern matching</h2>

          <aside class="notes">
            <a href="https://docs.microsoft.com/en-gb/dotnet/csharp/pattern-matching"></a>
          </aside>
        </section>
        <section>
          <h2>"Is" pattern</h2>

          <pre><code class="cs" data-trim data-noescape>
            if (p <span class="fragment highlight-mark" data-fragment-index="1">is Student</span>)
            {
              <span class="fragment highlight-mark" data-fragment-index="1">var s = (Student) p;</span>
                Console.WriteLine($"Index: {s.Index}");
            }
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>

            <pre><code class="cs" data-trim data-noescape>
              if (p <span class="fragment highlight-mark" data-fragment-index="1">is Student s</span>)
              {
                  Console.WriteLine($"Index: {s.Index}");
              }
            </code></pre>
          </span>


          <aside class="notes">
            Uwaga na ifologię, prawdopodobnie lepiej stworzyć dodatkowy interfejs
            IInfoPrinter i zrzucić odpowiedzialność przedstawiania się na klasy.
            Zaproponowane rozwiązanie jest podejściem funkcyjnym.
          </aside>
        </section>

        <section>
          <h2>IL</h2>

          <div class="container-inline">
            <pre><code class="cs" data-trim data-noescape>
              IL_0001: ldarg.0
              IL_0002: isinst OutVariables.Student
              IL_0007: ldnull
              IL_0008: cgt.un
              IL_000a: stloc.0
              // sequence point: hidden
              IL_000b: ldloc.0
              IL_000c: brfalse.s IL_002d
          
              IL_000e: nop
              IL_000f: ldarg.0
              <span class="fragment highlight-red" data-fragment-index="1">IL_0010: castclass OutVariables.Student</span>
              IL_0015: stloc.1
            </code></pre>

            <span class="fragment fade-in">
              <i class="fas fa-long-arrow-alt-right"></i>
              <pre><code class="cs" data-trim data-noescape>
                IL_0001: ldarg.0
                IL_0002: isinst OutVariables.Student
                IL_0007: dup
                IL_0008: stloc.0
                IL_0009: ldnull
                IL_000a: cgt.un
                IL_000c: stloc.1
                // sequence point: hidden
                IL_000d: ldloc.1
                IL_000e: brfalse.s IL_0028
              </code></pre>
            </span>
          </div>
        </section>

        <section>
          <h2>Liskov is SO<b>L</b>ID</h2>

          <ul>
            <li class="fragment fade-in">Metoda musi znać wszystkie klasy rozszerzające klasę Person</li>
            <li class="fragment fade-in">Dodanie nowej klasy dziedziczącej zepsuje kod</li>
            <li class="fragment fade-in">Łamiemy enkapsulację</li>
          </ul>
        </section>
        <section>
          <h2>Uwaga na zasięg zmiennej!</h2>

          <pre><code class="cs" data-trim data-noescape>
                        static void OldPrintInfo(Person p)
                        {
                            Console.WriteLine($"FirstName: {p.FirstName}");
                            Console.WriteLine($"LastName: {p.LastName}");
                
                            if (p is Student s)<span class="fragment highlight-mark">
                            {
                                Console.WriteLine($"Index: {s.Index}");
                            }</span>
                            else if (p is Programmer)
                            {
                                var pr = (Programmer) p;
                                Console.WriteLine($"CSharp: {pr.CSharp}");
                                Console.WriteLine($"Java: {pr.Java}");
                            }
                        }
                        </code></pre>
        </section>
        <section>
          <h2>Co jest nie tak z "safe castem"</h2>

          <pre><code class="cs" data-trim data-noescape>
                        static void SafeCast()
                        {
                            object numbers = Enumerable.Range(-3, 10).ToArray();
                
                            foreach (var number in <span class="fragment highlight-mark" data-fragment-index="1">numbers as IEnumerable&lt;int&gt;</span>) <span class="fragment fade-in" style="color: red" data-fragment-index="1">NullPointerException</span>
                            {
                                Console.WriteLine(number);
                            }
                        }
                    </code></pre>

        </section>
        <section>
          <h2>Co jest nie tak z "safe castem" (2)</h2>

          <pre><code class="cs" data-trim data-noescape>
              private static void SafeCast()
                  {
                      object obj = Enumerable.Range(-3, 10).ToArray();
                      IEnumerator&lt;int&gt; enumerator = <span class="fragment highlight-mark">(obj as IEnumerable&lt;int&gt;).GetEnumerator()</span>;
                      try
                      {
                          while (enumerator.MoveNext())
                          {
                              int current = enumerator.Current;
                              Console.WriteLine(current);
                          }
                      }
                      finally
                      {
                          if (enumerator != null)
                          {
                              enumerator.Dispose();
                          }
                      }
                  }
            </code></pre>
        </section>
      </section>
      <section>
        <section>
          <h2>Discards</h2>

          <aside class="notes">
            <a href="https://docs.microsoft.com/en-gb/dotnet/csharp/discards"></a>
          </aside>
        </section>
        <section>
          <h2>Deconstruction</h2>

          <pre><code class="cs" data-trim data-noescape>
            var minAvgMax = (min: -3, avg: 10.0, max: 4);
            var (min, <span class="fragment highlight-mark">_, _</span>) = minAvgMax;
            Console.WriteLine(min);
          </code></pre>

          <aside class="notes">
            W kodzie pośrednim nie będziemy mieli zmiennych lokalnych dla odrzuconych parametrów.
            Krotka nadal jest tworzona w całości.
          </aside>
        </section>
        <section>
          <h2>Out variables</h2>

          <pre><code class="cs" data-trim data-noescape>
            string numberString = "42";

            if (int.TryParse(numberString, <span class="fragment highlight-mark">out _</span>))
            {
                //do some logic
            }
          </code></pre>
        </section>
        <section>
          <h2>Out variables - IL</h2>

          <pre><code data-trim data-noescape>
              IL_0007: ldloc.0
              IL_0008: ldloca.s 2
              IL_000a: call bool [mscorlib]System.Int32::TryParse(string, int32&)
              IL_000f: stloc.1
              // sequence point: hidden
              IL_0010: ldloc.1
              IL_0011: brfalse.s IL_0022
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>
            <pre><code data-trim data-noescape>
                  IL_0007: ldloc.0
                  IL_0008: ldloca.s 1
                  IL_000a: call bool [mscorlib]System.Int32::TryParse(string, int32&)
                  IL_000f: stloc.2
                  // sequence point: hidden
                  IL_0010: ldloc.2
                  IL_0011: brfalse.s IL_0022
              </code></pre>
          </span>

          <aside class="notes">
            Różnica w IL_000f wynika z innej kolejności zmiennych lokalnych.
            W obydwóch przypadkach IL generuje lokalną zmienną dla parametru "out"
          </aside>
        </section>
        <section>
          <h2>Standalone</h2>

          <pre><code class="cs" data-trim data-noescape>
              string numberString = "42";

              <span class="fragment highlight-mark">_ =</span> int.Parse(numberString);
          </code></pre>
        </section>

      </section>
      <section>
        <section>
          <h2>Local functions</h2>

          <div class="container-inline">
            <pre><code class="cs" data-trim data-noescape>
          static void PrintInterestingInfo(Programmer p, int indentationSize)
          {
              var indentation = new string(' ', indentationSize);
  
              Console.WriteLine("Person:");
              PrintIndented(p.FirstName, <span class="fragment highlight-mark" data-fragment-index="1">indentation</span>);
              PrintIndented(p.LastName, <span class="fragment highlight-mark" data-fragment-index="1">indentation</span>);
              PrintIndented(p.CSharp, <span class="fragment highlight-mark" data-fragment-index="1">indentation</span>);
              PrintIndented(p.Java, <span class="fragment highlight-mark" data-fragment-index="1">indentation</span>);
              PrintIndented(p.SightDefect, <span class="fragment highlight-mark" data-fragment-index="1">indentation</span>);
          }
          <span class="fragment highlight-mark" data-fragment-index="1">
          static void PrintIndented(object o, string indentation)
          {
              var text = o ?? "<NA>";
              Console.WriteLine(indentation + text);
          }
          </span>
          </code></pre>

            <span class="fragment fade-in">
              <i class="fas fa-long-arrow-alt-right"></i>
              <pre><code data-trim data-noescape>
                static void PrintInterestingInfo(Programmer p, int indentationSize)
                {
                    var indentation = new string(' ', indentationSize);
        
                    Console.WriteLine("Person:");
                    PrintIndented(p.FirstName);
                    PrintIndented(p.LastName);
                    PrintIndented(p.CSharp);
                    PrintIndented(p.Java);
                    PrintIndented(p.SightDefect);
        
                    <span class="fragment highlight-mark" data-fragment-index="1">
                    void PrintIndented(object o)
                    {
                        var text = o ?? "<NA>";
                        Console.WriteLine(indentation + text);
                    }
                  }
                </span>
              </code></pre>
            </span>
          </div>

          <aside class="notes">
            Przykład w VS
          </aside>

        </section>

        <section>
          <h2>Local functions - generowany kod</h2>

          <pre><code data-trim data-noescape>
              [StructLayout(LayoutKind.Auto)]
              [CompilerGenerated]
              private struct &lt;&gt;c__DisplayClass1_0
              {
                  public string indentation;
              }
          
              public void M(int n)
              {
              }
          
              private static void PrintInterestingInfo(Programmer p, int indentationSize)
              {
                  &lt;&gt;c__DisplayClass1_0 &lt;&gt;c__DisplayClass1_ = default(&lt;&gt;c__DisplayClass1_0);
                  &lt;&gt;c__DisplayClass1_.indentation = new string(' ', indentationSize);
                  Console.WriteLine("Person:");
                  &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(p.FirstName, ref &lt;&gt;c__DisplayClass1_);
                  &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(p.LastName, ref &lt;&gt;c__DisplayClass1_);
                  &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(p.CSharp, ref &lt;&gt;c__DisplayClass1_);
                  &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(p.Java, ref &lt;&gt;c__DisplayClass1_);
                  &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(((double, double))p.SightDefect, ref &lt;&gt;c__DisplayClass1_);
              }
          
              [CompilerGenerated]
              internal static void &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(object o, ref &lt;&gt;c__DisplayClass1_0 P_1)
              {
                  object arg = o ?? "";
                  Console.WriteLine(P_1.indentation + arg);
              }
          </code></pre>
        </section>

        <section>
          <h2>Lambda functions - generowany kod</h2>

          <pre><code data-trim data-noescape>
            [CompilerGenerated]
            private sealed class &lt;&gt;c__DisplayClass1_0
            {
                public string indentation;
        
                internal void &lt;MehPrintInterestingInfo&gt;b__0(object o)
                {
                    object arg = o ?? "&lt;NA&gt;";
                    Console.WriteLine(indentation + arg);
                }
            }
        
            public void M(int n)
            {
            }
        
            private static void MehPrintInterestingInfo(Programmer p, int indentationSize)
            {
                &lt;&gt;c__DisplayClass1_0 &lt;&gt;c__DisplayClass1_ = new &lt;&gt;c__DisplayClass1_0();
                &lt;&gt;c__DisplayClass1_.indentation = new string(' ', indentationSize);
                Action&lt;object&gt; action = &lt;&gt;c__DisplayClass1_.&lt;MehPrintInterestingInfo&gt;b__0;
                Console.WriteLine("Person:");
                action(p.FirstName);
                action(p.LastName);
                action(p.CSharp);
                action(p.Java);
                action(((double, double))p.SightDefect);
            }
          </code></pre>
        </section>
      </section>
      <section>
        <section>
          <h2>Ref local/return</h2>

          <aside class="notes">
            <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns"></a>
          </aside>
        </section>
        <section>
          <h2>Ref return</h2>

          <pre><code class="cs" data-trim data-noescape>
            class MyArray
            {
                int[] numbers;
    
                public int Length => numbers.Length;
    
                public MyArray(params int[] numbers)
                {
                    this.numbers = numbers;
                }
    
                internal <span class="fragment highlight-mark" data-fragment-index="1">ref int</span> this[int index] => <span class="fragment highlight-mark" data-fragment-index="1">ref</span> numbers[index];</span>
    
                internal void Print()
                {
                    foreach (var number in numbers)
                    {
                        Console.Write(number + " ");
                    }
                    Console.WriteLine();
                }
            }
          </code></pre>
        </section>
        <section>
          <h2>Ref local</h2>

          <pre><code class="cs" data-trim data-noescape>
            var evenNumbers = new MyArray(2, 4, 6, 8, 10);
            <span class="fragment highlight-mark" data-fragment-index="1">ref</span> var number = <span class="fragment highlight-mark" data-fragment-index="1">ref</span> evenNumbers[2];
          </code></pre>

          <aside class="notes">
            Przykłady w VS
          </aside>
        </section>
      </section>
      <section>
        <section>
          <h2>Lecimy tutaj</h2>
        </section>
        <section>
          <h2>Expression-bodied members</h2>

          <pre><code class="cs" data-trim data-noescape>
            // Expression-bodied constructor
            public ExpressionMembersExample(string label) <span class="fragment highlight-mark" data-fragment-index="1">=></span> this.Label = label;

            // Expression-bodied finalizer
            ~ExpressionMembersExample() <span class="fragment highlight-mark" data-fragment-index="1">=></span> Console.Error.WriteLine("Finalized!");

            private string label;

            // Expression-bodied get / set accessors.
            public string Label
            {
                get <span class="fragment highlight-mark" data-fragment-index="1">=></span> label;
                set <span class="fragment highlight-mark" data-fragment-index="1">=></span> this.label = value ?? "Default label";
            }
          </code></pre>
        </section>
        <section>
          <h2>Throw exceptions</h2>

          <pre><code class="cs" data-trim data-noescape>
            // Conditional expression
            public string Name
            {
                get => name;
                set => name = value ?? 
                    throw new ArgumentNullException(paramName: nameof(value), message: "New name must not be null");
            }

            // During initialization
            private ConfigResource loadedConfig = LoadConfigResourceOrDefault() ?? 
                throw new InvalidOperationException("Could not load config");
          </code></pre>
        </section>
        <section>
          <h2>Generalized async return types</h2>

          <p>Metody asynchroniczne mogą zwracać dowolny typ posiadający odpowiednia implementację</p>

          <pre><code class="cs" data-trim data-noescape>
            public async <span class="fragment highlight-mark">ValueTask&lt;int&gt;</span> Func()
            {
              await Task.Delay(100);
              return 5;
            }
          </code></pre>

          <a href="https://github.com/dotnet/roslyn/blob/master/docs/features/task-types.md">Roslyn - Task Types</a>
        </section>
        <section>
          <h2>Numeric literal syntax improvements</h2>
          <h3>Binary literals</h3>

          <pre><code class="cs" data-trim data-noescape>
            int One   = 0b0001;
            int Two   = 0b0010;
            int Four  = 0b0100;
            int Eight = 0b1000;
          </code></pre>

          <pre><code class="cs" data-trim data-noescape>
            int TwentySeven       = 27;
            int TwentySevenBinary = 0b11011;
            int TwentySevenHex    = 0x1B;
          </code></pre>
        </section>
        <section>
          <h2>Numeric literal syntax improvements</h2>
          <h3>Digit separator</h3>

          <pre><code class="cs" data-trim data-noescape>
              long pierdyliard = 1_000_000_420_069;
              int binaryMask   = 0b_1000_0000_1111_0000;
            </code></pre>
        </section>
      </section>
      <section>
        <h1>C# 7.1</h1>

        <aside class="notes">
          <a href="https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-1">
            https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-1</a>
          <a href="https://www.danielcrabtree.com/blog/329/c-sharp-7-1-everything-you-need-to-know">
            https://www.danielcrabtree.com/blog/329/c-sharp-7-1-everything-you-need-to-know</a>
        </aside>
      </section>
      <section>
        <section>
          <h1>Generic types pattern matching</h2>
        </section>

        <section>
          <h2>Generic types</h2>

          <pre><code class="cs" data-trim data-noescape>
              public static void WhatAmI&lt;T>(T me)
              {
                  switch (me)
                  {
                      case int _:
                          Console.WriteLine("I'm an int");
                          break;
                      case string _:
                          Console.WriteLine("I'm a string");
                          break;
                      case object _:
                          Console.WriteLine("I'm an object");
                          break;
                      default:
                          Console.WriteLine("I'm a ninja");
                          break;
                  }
              }
          </code></pre>
        </section>

        <section>
          <h2>Open types</h2>

          <pre><code class="cs" data-trim data-noescape>
              public static void WhatAmIExactly&lt;TParam&gt;(Action&lt;TParam> me)
              {
                  switch (me)
                  {
                      case Action&lt;int> _:
                          Console.WriteLine("I return an int");
                          break;
                      case Action&lt;object> _:
                          Console.WriteLine("I return an object");
                          break;
                      case Action&lt;string> _:
                          Console.WriteLine("I return a string");
                          break;
                      default:
                          Console.WriteLine("I'm a ninja");
                          break;
                  }
              }
          </code></pre>
        </section>
        <section>
          <h1>Demo</h1>
        </section>
      </section>
      <section>
        <section>
          <h2>Lecimy tutaj</h2>
        </section>
        <section>
          <h2>Async main</h2>

          <pre><code class="cs" data-trim data-noescape>
            static void Main()
            {
                DoAsyncWork().GetAwaiter().GetResult();
            }
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>

            <pre><code class="cs" data-trim data-noescape>
                static <span class="fragment highlight-mark">async Task</span> Main()
                {
                    await SomeAsyncMethod();
                }
              </code></pre>
          </span>
        </section>
        <section>
          <h2>Default value initializers</h2>

          <pre><code class="cs" data-trim data-noescape>
            public static void Run()
            {
                //variable initialization
                IDictionary<string, int> dictionary = <span class="fragment highlight-mark">default</span>;
    
                var printer = new MyPrinter("some name");
    
                //default parameter value
                printer.Print("It's me", <span class="fragment highlight-mark">default</span>);
            }
    
            class MyPrinter
            {
                private readonly string _name;
                private readonly string _defaultIndentation;
    
                //default parameter value
                public MyPrinter(string name, int defaultIndentation = <span class="fragment highlight-mark">default</span>)
                {
                    _name = name;
                    _defaultIndentation = new string(' ', defaultIndentation);
                    Console.WriteLine($"Created MyPrinter with name '{_name}'");
                }
    
                public void Print(object v, string prefix = ": ")
                {
                    Console.WriteLine(_defaultIndentation + prefix + v);
                }
            }
          </code></pre>
        </section>
        <section>
          <h2>Inferred tuple element names</h2>

          <pre><code class="cs" data-trim data-noescape>
            var min = 2;
            var max = 10;
            var avg = 5.5;
            var minAvgMax = (<span class="fragment highlight-mark" data-fragment-index="1">min:</span> min, <span class="fragment highlight-mark" data-fragment-index="1">avg:</span> avg, <span class="fragment highlight-mark" data-fragment-index="1">max:</span> max);
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>
            <pre><code class="cs" data-trim data-noescape>
              var min = 2;
              var max = 10;
              var avg = 5.5;
              var minAvgMax = (min, avg, max);
            </code></pre>
          </span>
        </section>
      </section>
      <section>
        <h1>C# 7.2</h1>

        <aside class="notes">
          <a href="https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-2">
            https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-2</a>
        </aside>
      </section>
      <section>In parameters</section>
      <section>Praktyczny przykład</section>
      <section>Ref struct widmo</section>
      <section>Span</section>
      <section>Memory</section>
      <section>Ref readonly</section>
      <section>Readonly struct</section>
      <section>Non-trailing named arguments</section>
      <section>Private protected</section>
      <section>
        <h1>C# 7.3</h1>
      </section>
      <section>Dodatkowe ograniczenia typów (w końcu!)</section>
      <section>Ref local reassignment</section>
      <section>Tuples equality</section>
      <section>Backing-fields attributes</section>
      <section>
        <h1>Co na horyzoncie? C# 8</h1>
      </section>
      <section>Jeszcze bardziej rozbudowany pattern-matching i dekonstrukcja</section>
      <section>Nullable reference types</section>
      <section>Record classes</section>
      <section>Domyślne implementacje interfejsów</section>
      <section>Async streams</section>
      <section>Ranges</section>
      <section>Genericzne atrybuty</section>
      <section>Target-typed new</section>
      <section>Podsumowanie</section>
      <section>Materiały</section>
      <section>Pytania</section>

    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        {
          src: 'plugin/highlight/highlight.js',
          async: true,
          callback: function () {
            hljs.initHighlightingOnLoad();
          }
        },
        { src: 'node_modules/reveal.js-menu/menu.js' }
      ],
      menu: {
        numbers: true,
        themes: true,
        loadIcons: false
      },
      width: '100%',
      height: '100%'
    });
  </script>
</body>

</html>
