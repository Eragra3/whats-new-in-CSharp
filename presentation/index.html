<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/dracula.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU"
    crossorigin="anonymous">
</head>

<body>
  <div class="reveal">
    <div class="slides">

      <section>
        <img src="res/cshark-logo.png" />

        <pre><code class="cs" data-trim data-noescape style="font-size: 3em; height: 1.15em; line-height: 1em">
          Console.WriteLine("Hello Sharks!");
        </code></pre>
      </section>

      <section>
        <h2>Nowości w języku
          <span class="fragment strike">Cool</span>
          <span class="fragment fade-in">C#</span>
        </h2>
        <p class="fragment fade-in-and-out">C-like Object Oriented Language</p>

        <h3>
          Daniel Bider
        </h3>

        <aside class="notes">
          <p>Biblioteka napisana w Simple Managed C (SMC), potem sportowana do C#</p>>
        </aside>
      </section>

      <section>
        <h2>Krótka historia C#</h2>
        <span class="fragment fade-in">Rok powstania: </span>
        <span class="fragment fade-in">1999</span>
        <br \>
        <span class="fragment fade-in">Twórca: </span>
        <span class="fragment fade-in">Anders Hejlsberg</span>

        <aside class="notes">
          <p>Java - 1995, Ryan Gosling</p>
          <p>C++ - 1985, Bjarne Stroustrup</p>
        </aside>
      </section>

      <section>
        <h2>Wersje C#</h2>

        <div class="fragment fade-in">
          <h3>C# 1.0 (1.1, 1.2)</h3>
          <p class="fragment fade-in">nic ciekawego</p>
        </div>

        <aside class="notes">
          <p>brak generyków, nie ma LINQ, kalka Javy (twórcy twierdzą, że nie kalka)</p>
        </aside>
      </section>

      <section>
        <h3>C# 2.0</h3>
        <ul class="fragment fade-in">
          <li>Generics</li>
          <li>Nullable types</li>
          <li>Delegates</li>
          <li>Anonymous methods</li>
          <li>Partial types</li>
          <li>Static classes</li>
          <li>Variance</li>
        </ul>
      </section>

      <section>
        <h3>C# 3.0</h3>
        <ul class="fragment fade-in">
          <li><i>Var</i> keyword</li>
          <li>Lambdas</li>
          <li>Object and collection initializers</li>
          <li>Auto-properties</li>
          <li>Extension methods</li>
          <li>Partial methods</li>
        </ul>
      </section>

      <section>
        <h3>C# 4.0</h3>
        <ul class="fragment fade-in">
          <li>Dynamic binding...</li>
          <li>Generic variance</li>
        </ul>
      </section>

      <section>
        <h3>C# 5.0</h3>
        <ul class="fragment fade-in">
          <li>Async</li>
        </ul>
      </section>

      <section>
        <h3>C# 6.0</h3>
        <ul class="fragment fade-in">
          <li><b>Compiler-as-a-service (Roslyn)</b></li>
          <li>Auto property initializers</li>
          <li>String interpolation</li>
          <li>Nameof operator</li>
          <li>Exception filters</li>
          <li>Null propagator</li>
          <li>Dictionary initializer</li>
        </ul>

        <aside class="notes">
          <p>C#6 <a href="https://github.com/dotnet/roslyn/wiki/Languages-features-in-C%23-6-and-VB-14"></a></p>
        </aside>
      </section>

      <section>
        <h1>C# 7.0</h1>

        <aside class="notes">
          <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7"></a>
        </aside>
      </section>
      <section>

        <section>
          <h2>Inline out variables</h2>

          <pre><code class="cs" data-trim data-noescape>
            string numberString = "42";

            <span class="fragment highlight-mark" data-fragment-index="1">int number;</span>
            if (int.TryParse(numberString, <span class="fragment highlight-mark" data-fragment-index="1">out number</span>))
            {
                int nextNumber = number + 1;
            (...)
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>

            <pre><code class="cs" data-trim data-noescape>
              string numberString = "42";

              if (int.TryParse(numberString, <span class="fragment highlight-mark">out int number</span>))
              {
                  int nextNumber = number + 1;
              (...)
            </code></pre>
          </span>
        </section>

        <section>
          <h2>IL</h2>
          <pre><code class="cs" data-trim data-noescape>
            IL_0007: ldloc.0
            IL_0008: ldloca.s 1
            IL_000a: call bool [mscorlib]System.Int32::TryParse(string, int32&)
            IL_000f: stloc.2
            // sequence point: hidden
            IL_0010: ldloc.2
            IL_0011: brfalse.s IL_0031
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>
            <pre><code class="cs" data-trim data-noescape>
              IL_0007: ldloc.0
              IL_0008: ldloca.s 1
              IL_000a: call bool [mscorlib]System.Int32::TryParse(string, int32&)
              IL_000f: stloc.2
              // sequence point: hidden
              IL_0010: ldloc.2
              IL_0011: brfalse.s IL_0031
            </code></pre>
          </span>

          <aside class="notes">
            <table>
              <thead>
                <th>operation</th>
                <th>description</th>
              </thead>
              <tbody>
                <tr>
                  <td>ldloc.0</td>
                  <td>Load local variable 0 onto stack.</td>
                </tr>
                <tr>
                  <td>ldloca.s &lt;uint8 (indx)&gt;</td>
                  <td>Load address of local variable with index indx, short form.</td>
                </tr>
              </tbody>
            </table>
          </aside>
        </section>

        <section>
          <h2>Uwaga na zasięg zmiennej!</h2>

          <pre><code class="cs" data-trim data-noescape>
            static void Main(string[] args)
            {
                string numberString = "42";
                for (int i = 0; i < 100; i++)<span class="fragment highlight-mark" data-fragment-index="2">
                {
                    if (int.TryParse(numberString, <span class="fragment highlight-mark" data-fragment-index="1">out int number</span>))
                    {
                        int nextNumber = number + 1;
                        Console.WriteLine($"Next person number is {nextNumber}");
                    }
                    else
                    {
                        Console.WriteLine("Invalid number");
                    }
                }</span>
            }
            </code></pre>
        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>

      <section>
        <section>
          <h2>Tuples</h2>

          <pre><code class="cs" data-trim data-noescape>
            var t1 = new Tuple&lt;int, double, int&gt;(-3, 10.0, 4);
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>

            <pre><code class="cs" data-trim data-noescape>
              var t1 = (-3, 10.0, 4);
            </code></pre>
          </span>
        </section>
        <section>
          <h2>Named tuple elements</h2>

          <pre><code class="cs" data-trim data-noescape>
            var t1 = (<span class="fragment highlight-mark" data-fragment-index="1">min:</span> -3, <span class="fragment highlight-mark" data-fragment-index="1">avg:</span> 10.0, <span class="fragment highlight-mark" data-fragment-index="1">max:</span> 4);
            Console.WriteLine(t1.min);
          </code></pre>
        </section>

        <section>
          <h2>Deconstruction</h2>

          <pre><code class="cs" data-trim data-noescape>
            var minAvgMax = (min: -3, avg: 10.0, max: 4);
            var <span class="fragment highlight-mark" data-fragment-index="1">(min, avg, max)</span> = minAvgMax;
            Console.WriteLine(min);
          </code></pre>
        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>

      <section>
        <section>
          <h2>Pattern matching</h2>

          <aside class="notes">
            <a href="https://docs.microsoft.com/en-gb/dotnet/csharp/pattern-matching"></a>
          </aside>
        </section>
        <section>
          <h2><i>Is</i> pattern</h2>

          <pre><code class="cs" data-trim data-noescape>
            if (p <span class="fragment highlight-mark" data-fragment-index="1">is Student</span>)
            {
              <span class="fragment highlight-mark" data-fragment-index="1">var s = (Student) p;</span>
                Console.WriteLine($"Index: {s.Index}");
            }
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>

            <pre><code class="cs" data-trim data-noescape>
              if (p <span class="fragment highlight-mark" data-fragment-index="1">is Student s</span>)
              {
                  Console.WriteLine($"Index: {s.Index}");
              }
            </code></pre>
          </span>


          <aside class="notes">
            Uwaga na ifologię, prawdopodobnie lepiej stworzyć dodatkowy interfejs
            IInfoPrinter i zrzucić odpowiedzialność przedstawiania się na klasy.
            Zaproponowane rozwiązanie jest podejściem funkcyjnym.
          </aside>
        </section>

        <section>
          <h2>IL</h2>

          <div class="container-inline">
            <pre><code class="cs" data-trim data-noescape>
              IL_0001: ldarg.0
              IL_0002: isinst OutVariables.Student
              IL_0007: ldnull
              IL_0008: cgt.un
              IL_000a: stloc.0
              // sequence point: hidden
              IL_000b: ldloc.0
              IL_000c: brfalse.s IL_002d
          
              IL_000e: nop
              IL_000f: ldarg.0
              <span class="fragment highlight-red" data-fragment-index="1">IL_0010: castclass OutVariables.Student</span>
              IL_0015: stloc.1
            </code></pre>

            <span class="fragment fade-in">
              <i class="fas fa-long-arrow-alt-right"></i>
              <pre><code class="cs" data-trim data-noescape>
                IL_0001: ldarg.0
                IL_0002: isinst OutVariables.Student
                IL_0007: dup
                IL_0008: stloc.0
                IL_0009: ldnull
                IL_000a: cgt.un
                IL_000c: stloc.1
                // sequence point: hidden
                IL_000d: ldloc.1
                IL_000e: brfalse.s IL_0028
              </code></pre>
            </span>
          </div>
        </section>

        <section>
          <h2>When clauses</h2>

          <pre><code class="cs" data-trim data-noescape>
            if (p is IHasSightDefect)
            {
                var hsd = (IHasSightDefect)p;

                if (Math.Abs(hsd.SightDefect.leftEye) > 2 || Math.Abs(hsd.SightDefect.rightEye) > 2)
                {
                    Console.WriteLine("\tSight problems");
                }
            }
            // Can't put else here!
            if (p is Programmer)
            {
                var pr = (Programmer)p;

                if (pr.CSharp > SkillLevel.Basic || pr.Java > SkillLevel.Basic)
                {
                    Console.WriteLine("\tGreat programmer!");
                }
                else if (pr.CSharp == SkillLevel.None && pr.CSharp == SkillLevel.None)
                {
                    Console.WriteLine("\tNo skill :C. Go JavaScript");
                }
                else
                {
                    Console.WriteLine("\tRegular programmer");
                }
            }
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>

            <pre><code class="cs" data-trim data-noescape>
                switch (p)
                {
                    case IHasSightDefect hsd when Math.Abs(hsd.SightDefect.leftEye) > 2 || Math.Abs(hsd.SightDefect.rightEye) > 2:
    
                        Console.WriteLine("\tSight problems");
                        break;
    
                    case Programmer pr when pr.CSharp > SkillLevel.Basic || pr.Java > SkillLevel.Basic:
    
                        Console.WriteLine("\tGreat programmer!");
                        break;
    
                    case Programmer pr when pr.CSharp == SkillLevel.None && pr.CSharp == SkillLevel.None:
    
                        Console.WriteLine("\tNo skill :C. Go JavaScript");
                        break;
    
                    case Programmer _:
    
                        Console.WriteLine("\tRegular programmer");
                        break;
                }
            </code></pre>
          </span>
        </section>

        <section>
          <h2>Liskov is SO<b>L</b>ID</h2>

          <ul>
            <li class="fragment fade-in">Metoda musi znać wszystkie klasy rozszerzające klasę Person</li>
            <li class="fragment fade-in">Dodanie nowej klasy dziedziczącej zepsuje kod</li>
            <li class="fragment fade-in">Łamiemy enkapsulację</li>
          </ul>
        </section>
        <section>
          <h2>Uwaga na zasięg zmiennej!</h2>

          <pre><code class="cs" data-trim data-noescape>
                        static void OldPrintInfo(Person p)
                        {
                            Console.WriteLine($"FirstName: {p.FirstName}");
                            Console.WriteLine($"LastName: {p.LastName}");
                
                            if (p is Student s)<span class="fragment highlight-mark">
                            {
                                Console.WriteLine($"Index: {s.Index}");
                            }</span>
                            else if (p is Programmer)
                            {
                                var pr = (Programmer) p;
                                Console.WriteLine($"CSharp: {pr.CSharp}");
                                Console.WriteLine($"Java: {pr.Java}");
                            }
                        }
                        </code></pre>
        </section>
        <section>
          <h2>Co jest nie tak z "safe castem"</h2>

          <pre><code class="cs" data-trim data-noescape>
              static void SafeCast()
              {
                  object numbers = Enumerable.Range(-3, 10).ToList();
      
                  foreach (var number in <span class="fragment highlight-mark">numbers as int[]</span>)<span class="fragment fade-in" style="color: red" data-fragment-index="1"> NullPointerException</span>
                  {
                      Console.WriteLine(number);
                  }
              }
          </code></pre>

        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>

      <section>
        <section>
          <h2>Discards</h2>

          <aside class="notes">
            <a href="https://docs.microsoft.com/en-gb/dotnet/csharp/discards"></a>
          </aside>
        </section>
        <section>
          <h2>Deconstruction</h2>

          <pre><code class="cs" data-trim data-noescape>
            var minAvgMax = (min: -3, avg: 10.0, max: 4);
            var (min, <span class="fragment highlight-mark">_, _</span>) = minAvgMax;
            Console.WriteLine(min);
          </code></pre>

          <aside class="notes">
            W kodzie pośrednim nie będziemy mieli zmiennych lokalnych dla odrzuconych parametrów.
            Krotka nadal jest tworzona w całości.
          </aside>
        </section>
        <section>
          <h2>Out variables</h2>

          <pre><code class="cs" data-trim data-noescape>
            string numberString = "42";

            if (int.TryParse(numberString, <span class="fragment highlight-mark">out _</span>))
            {
                //do some logic
            }
          </code></pre>
        </section>
        <section>
          <h2>Out variables - IL</h2>

          <pre><code data-trim data-noescape>
              IL_0007: ldloc.0
              IL_0008: ldloca.s 2
              IL_000a: call bool [mscorlib]System.Int32::TryParse(string, int32&)
              IL_000f: stloc.1
              // sequence point: hidden
              IL_0010: ldloc.1
              IL_0011: brfalse.s IL_0022
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>
            <pre><code data-trim data-noescape>
                  IL_0007: ldloc.0
                  IL_0008: ldloca.s 1
                  IL_000a: call bool [mscorlib]System.Int32::TryParse(string, int32&)
                  IL_000f: stloc.2
                  // sequence point: hidden
                  IL_0010: ldloc.2
                  IL_0011: brfalse.s IL_0022
              </code></pre>
          </span>

          <aside class="notes">
            Różnica w IL_000f wynika z innej kolejności zmiennych lokalnych.
            W obydwóch przypadkach IL generuje lokalną zmienną dla parametru "out"
          </aside>
        </section>
        <section>
          <h2>Standalone</h2>

          <pre><code class="cs" data-trim data-noescape>
              string numberString = "42";

              <span class="fragment highlight-mark">_ =</span> int.Parse(numberString);
          </code></pre>
        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>
      <section>
        <section>
          <h2>Local functions</h2>

          <div class="container-inline">
            <pre><code class="cs" data-trim data-noescape>
          static void PrintInterestingInfo(Programmer p, int indentationSize)
          {
              var indentation = new string(' ', indentationSize);
  
              Console.WriteLine("Person:");
              PrintIndented(p.FirstName, <span class="fragment highlight-mark" data-fragment-index="1">indentation</span>);
              PrintIndented(p.LastName, <span class="fragment highlight-mark" data-fragment-index="1">indentation</span>);
              PrintIndented(p.CSharp, <span class="fragment highlight-mark" data-fragment-index="1">indentation</span>);
              PrintIndented(p.Java, <span class="fragment highlight-mark" data-fragment-index="1">indentation</span>);
              PrintIndented(p.SightDefect, <span class="fragment highlight-mark" data-fragment-index="1">indentation</span>);
          }
          <span class="fragment highlight-mark" data-fragment-index="1">
          static void PrintIndented(object o, string indentation)
          {
              var text = o ?? "<NA>";
              Console.WriteLine(indentation + text);
          }
          </span>
          </code></pre>

            <span class="fragment fade-in">
              <i class="fas fa-long-arrow-alt-right"></i>
              <pre><code data-trim data-noescape>
                static void PrintInterestingInfo(Programmer p, int indentationSize)
                {
                    var indentation = new string(' ', indentationSize);
        
                    Console.WriteLine("Person:");
                    PrintIndented(p.FirstName);
                    PrintIndented(p.LastName);
                    PrintIndented(p.CSharp);
                    PrintIndented(p.Java);
                    PrintIndented(p.SightDefect);
        
                    <span class="fragment highlight-mark" data-fragment-index="1">
                    void PrintIndented(object o)
                    {
                        var text = o ?? "<NA>";
                        Console.WriteLine(indentation + text);
                    }
                  }
                </span>
              </code></pre>
            </span>
          </div>
        </section>

        <section>
          <h2>Local functions - generowany kod</h2>

          <pre><code data-trim data-noescape>
              [StructLayout(LayoutKind.Auto)]
              [CompilerGenerated]
              private struct &lt;&gt;c__DisplayClass1_0
              {
                  public string indentation;
              }
          
              public void M(int n)
              {
              }
          
              private static void PrintInterestingInfo(Programmer p, int indentationSize)
              {
                  &lt;&gt;c__DisplayClass1_0 &lt;&gt;c__DisplayClass1_ = default(&lt;&gt;c__DisplayClass1_0);
                  &lt;&gt;c__DisplayClass1_.indentation = new string(' ', indentationSize);
                  Console.WriteLine("Person:");
                  &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(p.FirstName, ref &lt;&gt;c__DisplayClass1_);
                  &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(p.LastName, ref &lt;&gt;c__DisplayClass1_);
                  &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(p.CSharp, ref &lt;&gt;c__DisplayClass1_);
                  &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(p.Java, ref &lt;&gt;c__DisplayClass1_);
                  &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(((double, double))p.SightDefect, ref &lt;&gt;c__DisplayClass1_);
              }
          
              [CompilerGenerated]
              internal static void &lt;PrintInterestingInfo&gt;g__PrintIndented|1_0(object o, ref &lt;&gt;c__DisplayClass1_0 P_1)
              {
                  object arg = o ?? "";
                  Console.WriteLine(P_1.indentation + arg);
              }
          </code></pre>
        </section>

        <section>
          <h2>Lambda functions - generowany kod</h2>

          <pre><code data-trim data-noescape>
            [CompilerGenerated]
            private sealed class &lt;&gt;c__DisplayClass1_0
            {
                public string indentation;
        
                internal void &lt;MehPrintInterestingInfo&gt;b__0(object o)
                {
                    object arg = o ?? "&lt;NA&gt;";
                    Console.WriteLine(indentation + arg);
                }
            }
        
            public void M(int n)
            {
            }
        
            private static void MehPrintInterestingInfo(Programmer p, int indentationSize)
            {
                &lt;&gt;c__DisplayClass1_0 &lt;&gt;c__DisplayClass1_ = new &lt;&gt;c__DisplayClass1_0();
                &lt;&gt;c__DisplayClass1_.indentation = new string(' ', indentationSize);
                Action&lt;object&gt; action = &lt;&gt;c__DisplayClass1_.&lt;MehPrintInterestingInfo&gt;b__0;
                Console.WriteLine("Person:");
                action(p.FirstName);
                action(p.LastName);
                action(p.CSharp);
                action(p.Java);
                action(((double, double))p.SightDefect);
            }
          </code></pre>
        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>

      <section>
        <section>
          <h2>Ref local/return</h2>

          <aside class="notes">
            <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns"></a>
          </aside>
        </section>
        <section>
          <h2>Ref return</h2>

          <pre><code class="cs" data-trim data-noescape>
            class MyArray
            {
                int[] numbers;
    
                public int Length => numbers.Length;
    
                public MyArray(params int[] numbers)
                {
                    this.numbers = numbers;
                }
    
                internal <span class="fragment highlight-mark" data-fragment-index="1">ref int</span> this[int index] => <span class="fragment highlight-mark" data-fragment-index="1">ref</span> numbers[index];</span>
    
                internal void Print()
                {
                    foreach (var number in numbers)
                    {
                        Console.Write(number + " ");
                    }
                    Console.WriteLine();
                }
            }
          </code></pre>
        </section>
        <section>
          <h2>Ref local</h2>

          <pre><code class="cs" data-trim data-noescape>
            var evenNumbers = new MyArray(2, 4, 6, 8, 10);
            <span class="fragment highlight-mark" data-fragment-index="1">ref</span> var number = <span class="fragment highlight-mark" data-fragment-index="1">ref</span> evenNumbers[2];
          </code></pre>
        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>
      <section>
        <section>
          <h2>Lecimy tutaj</h2>
        </section>
        <section>
          <h2>Expression-bodied members</h2>

          <pre><code class="cs" data-trim data-noescape>
            // Expression-bodied constructor
            public ExpressionMembersExample(string label) <span class="fragment highlight-mark" data-fragment-index="1">=></span> this.Label = label;

            // Expression-bodied finalizer
            ~ExpressionMembersExample() <span class="fragment highlight-mark" data-fragment-index="1">=></span> Console.Error.WriteLine("Finalized!");

            private string label;

            // Expression-bodied get / set accessors.
            public string Label
            {
                get <span class="fragment highlight-mark" data-fragment-index="1">=></span> label;
                set <span class="fragment highlight-mark" data-fragment-index="1">=></span> this.label = value ?? "Default label";
            }
          </code></pre>
        </section>
        <section>
          <h2>Throw exceptions</h2>

          <pre><code class="cs" data-trim data-noescape>
            // Conditional expression
            public string Name
            {
                get => name;
                set => name = value ?? 
                    throw new ArgumentNullException(paramName: nameof(value), message: "New name must not be null");
            }

            // During initialization
            private ConfigResource loadedConfig = LoadConfigResourceOrDefault() ?? 
                throw new InvalidOperationException("Could not load config");
          </code></pre>
        </section>
        <section>
          <h2>Generalized async return types</h2>

          <p>Metody asynchroniczne mogą zwracać dowolny typ posiadający odpowiednia implementację</p>

          <pre><code class="cs" data-trim data-noescape>
            public async <span class="fragment highlight-mark">ValueTask&lt;int&gt;</span> Func()
            {
              await Task.Delay(100);
              return 5;
            }
          </code></pre>

          <a href="https://github.com/dotnet/roslyn/blob/master/docs/features/task-types.md">Roslyn - Task Types</a>
        </section>
        <section>
          <h2>Numeric literal syntax improvements</h2>
          <h3>Binary literals</h3>

          <pre><code class="cs" data-trim data-noescape>
            int One   = 0b0001;
            int Two   = 0b0010;
            int Four  = 0b0100;
            int Eight = 0b1000;
          </code></pre>

          <pre><code class="cs" data-trim data-noescape>
            int TwentySeven       = 27;
            int TwentySevenBinary = 0b11011;
            int TwentySevenHex    = 0x1B;
          </code></pre>
        </section>
        <section>
          <h2>Numeric literal syntax improvements</h2>
          <h3>Digit separator</h3>

          <pre><code class="cs" data-trim data-noescape>
              long pierdyliard = 1_000_000_420_069;
              int binaryMask   = 0b_1000_0000_1111_0000;
            </code></pre>
        </section>
      </section>
      <section>
        <h1>C# 7.1</h1>

        <aside class="notes">
          <a href="https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-1">
            https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-1</a>
          <a href="https://www.danielcrabtree.com/blog/329/c-sharp-7-1-everything-you-need-to-know">
            https://www.danielcrabtree.com/blog/329/c-sharp-7-1-everything-you-need-to-know</a>
        </aside>
      </section>
      <section>
        <section>
          <h1>Generic types pattern matching</h2>
        </section>

        <section>
          <h2>Generic types</h2>

          <pre><code class="cs" data-trim data-noescape>
              public static void WhatAmI&lt;T>(T me)
              {
                  switch (me)
                  {
                      case int _:
                          Console.WriteLine("I'm an int");
                          break;
                      case string _:
                          Console.WriteLine("I'm a string");
                          break;
                      case object _:
                          Console.WriteLine("I'm an object");
                          break;
                      default:
                          Console.WriteLine("I'm a ninja");
                          break;
                  }
              }
          </code></pre>
        </section>

        <section>
          <h2>Open types</h2>

          <pre><code class="cs" data-trim data-noescape>
              public static void WhatAmIExactly&lt;TParam&gt;(Action&lt;TParam> me)
              {
                  switch (me)
                  {
                      case Action&lt;int> _:
                          Console.WriteLine("I return an int");
                          break;
                      case Action&lt;object> _:
                          Console.WriteLine("I return an object");
                          break;
                      case Action&lt;string> _:
                          Console.WriteLine("I return a string");
                          break;
                      default:
                          Console.WriteLine("I'm a ninja");
                          break;
                  }
              }
          </code></pre>
        </section>
        <section>
          <h1>Demo</h1>
        </section>
      </section>
      <section>
        <section>
          <h2>Lecimy tutaj</h2>
        </section>
        <section>
          <h2>Async main</h2>

          <pre><code class="cs" data-trim data-noescape>
            static void Main()
            {
                DoAsyncWork().GetAwaiter().GetResult();
            }
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>

            <pre><code class="cs" data-trim data-noescape>
                static <span class="fragment highlight-mark">async Task</span> Main()
                {
                    await SomeAsyncMethod();
                }
              </code></pre>
          </span>
        </section>
        <section>
          <h2>Default value initializers</h2>

          <pre><code class="cs" data-trim data-noescape>
            public static void Run()
            {
                //variable initialization
                IDictionary<string, int> dictionary = <span class="fragment highlight-mark">default</span>;
    
                var printer = new MyPrinter("some name");
    
                //default parameter value
                printer.Print("It's me", <span class="fragment highlight-mark">default</span>);
            }
    
            class MyPrinter
            {
                private readonly string _name;
                private readonly string _defaultIndentation;
    
                //default parameter value
                public MyPrinter(string name, int defaultIndentation = <span class="fragment highlight-mark">default</span>)
                {
                    _name = name;
                    _defaultIndentation = new string(' ', defaultIndentation);
                    Console.WriteLine($"Created MyPrinter with name '{_name}'");
                }
    
                public void Print(object v, string prefix = ": ")
                {
                    Console.WriteLine(_defaultIndentation + prefix + v);
                }
            }
          </code></pre>
        </section>
        <section>
          <h2>Inferred tuple element names</h2>

          <pre><code class="cs" data-trim data-noescape>
            var min = 2;
            var max = 10;
            var avg = 5.5;
            var minAvgMax = (<span class="fragment highlight-mark" data-fragment-index="1">min:</span> min, <span class="fragment highlight-mark" data-fragment-index="1">avg:</span> avg, <span class="fragment highlight-mark" data-fragment-index="1">max:</span> max);
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>
            <pre><code class="cs" data-trim data-noescape>
              var min = 2;
              var max = 10;
              var avg = 5.5;
              var minAvgMax = (min, avg, max);
            </code></pre>
          </span>
        </section>
      </section>
      <section>
        <h1>C# 7.2</h1>

        <aside class="notes">
          <a href="https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-2">
            https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-2</a>
        </aside>
      </section>

      <section>
        <section>
          <h1>In parameters</h1>

          <pre><code class="cs" data-trim data-noescape>
            static void Print(<span class="fragment highlight-mark">in</span> int number)
            {
                Console.WriteLine(number);
            }
          </code></pre>
        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>

      <section>
        <section>
          <h2>Ref readonly</h2>

          <pre><code class="cs" data-trim data-noescape>
            static <span class="fragment highlight-mark" data-fragment-index="1">ref readonly</span> int GetReadonlyRef(in int number)
            {
                return <span class="fragment highlight-mark" data-fragment-index="1">ref</span> number;
            }
          </code></pre>
        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>

      <section>
        <section>
          <h2>Readonly struct</h2>

          <pre><code class="cs" data-trim data-noescape>
          <span class="fragment highlight-mark">readonly</span> struct Point3D
            {
                public readonly double X;
                public readonly double Y;
                public readonly double Z;

                public Point3D(double x, double y, double z)
                {
                    X = x;
                    Y = y;
                    Z = z;
                }
            }
          </code></pre>
        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>

      <section>
        <section>
          <h2>Ref struct</h2>
          <ul>
            <li>
              Struktura będzie zawsze alokowana na stosie
              <ul>
                <li>nie może być członkiem klasy</li>
                <li>nie może być użyta w miejscach, które wymagają alokacji na stercie</li>
              </ul>
            </li>
          </ul>

          <pre><code class="cs" data-trim data-noescape>
            <span class="fragment highlight-mark" data-fragment-index="1"><span class="fragment fade-in">readonly</span> ref</span> struct Point3dOn_ReadOnlyStack
            {
                public readonly double X;
                public readonly double Y;
                public readonly double Z;

                public Point3dOn_ReadOnlyStack(double x, double y, double z)
                {
                    X = x;
                    Y = y;
                    Z = z;
                }
            }
        </code></pre>

        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>

      <section>
        <section>
          <h2>Span</h2>

          <pre><code class="cs" data-trim data-noescape>
            public readonly ref struct Span&lt;T>
            {
              private readonly ref T _pointer;
              private readonly int _length;
              ...
            }
          </code></pre>
        </section>

        <section>
          <h2>Stack allocation</h2>

          <pre><code class="cs" data-trim data-noescape>
            unsafe
            {
                char* text = stackalloc char[ArraySize];
            }
          </code></pre>

          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>
            <pre><code class="cs" data-trim data-noescape>
            Span&lt;char> text = stackalloc char[ArraySize];
          </code></pre>
          </span>

          <aside class="notes">
            <a href="https://blogs.msdn.microsoft.com/mazhou/2018/03/25/c-7-series-part-10-spant-and-universal-memory-management/">
              https://blogs.msdn.microsoft.com/mazhou/2018/03/25/c-7-series-part-10-spant-and-universal-memory-management/</a>
          </aside>

        </section>

        <section>
          <h2>String as ReadOnlySpan</h2>

          <pre><code class="cs" data-trim data-noescape>
              var text = "A very nice string";
              ReadOnlySpan&lt;char> readonlySpan =  text.AsSpan();

              Console.WriteLine(text[4]);
            </code></pre>
        </section>

        <section>
          <h2>String slices</h2>

          <pre><code class="cs" data-trim data-noescape>
                var text = "A very nice string";
                ReadOnlySpan&lt;char> readonlySpan =  text.AsSpan();
                // no heap allocation
                ReadOnlySpan&lt;char> slice = readonlySpan.Slice(2, 9);
            </code></pre>
        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>

      <section>
        <section>
          <h2>Memory</h2>

          <pre><code class="cs" data-trim data-noescape>
            public readonly struct Memory&lt;T>
            {
              private readonly object _object;
              private readonly int _index;
              private readonly int _length;
              ...
            }
          </code></pre>
        </section>

        <section>
          <h1>Demo</h1>
        </section>
      </section>

      <section>
        <h2>Private protected</h2>

        <span class="fragment fade-in" data-fragment-index="1">
          <ul>
            <li>Typy dzieciczące w tym samym projekcie mają dostęp (protected)</li>
            <li>Typy poza projektem nie mają dostępu (private)</li>
          </ul>
        </span>

        <h2>Protected internal</h2>

        <span class="fragment fade-in" data-fragment-index="2">
          <ul>
            <li>Typy w tym samym projekcie mają dostęp (internal)</li>
            <li>Typy dzieciczące poza projektem mają dostępu (protected)</li>
          </ul>
        </span>

      </section>
      </section>

      <section>
        <section>
          <h2>Lecimy tutaj</h2>
        </section>

        <section>
          <h2>Non-trailing named arguments</h2>

          <pre><code class="cs" data-trim data-noescape>
              LotsParameters("HelloWorld", ": ", infix: "", postfix: ";");
          </code></pre>


          <span class="fragment fade-in">
            <i class="fas fa-long-arrow-alt-down"></i>
            <pre><code class="cs" data-trim data-noescape>
              LotsParameters("HelloWorld", ": ", infix: "",<span class="fragment highlight-mark"> </span>";");
            </code></pre>
          </span>
        </section>
      </section>

      <section>
        <h1>C# 7.3</h1>

        <aside class="notes">
          <a href="https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-3">
            https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-3</a>
        </aside>
      </section>

      <section>
        <h2>Tuples equality</h2>

        <pre><code class="cs" data-trim data-noescape>
            var equals = (10, 2, "kek") == (11, 2, "kek");
           </code></pre>

        <span class="fragment fade-in">
          <h3>Generated code</h3>
          <pre><code class="cs" data-trim data-noescape>
                bool flag = 10 == 11 && 2 == 2 && "kek" == "kek";
             </code></pre>
        </span>
      </section>

      <section>
        <h2>Enhanced generic constraints</h2>

        <pre><code class="cs" data-trim data-noescape>
            static void RequireEnum&lt;T>(T param) where T: Enum
            {
                throw new NotImplementedException();
            }
    
            static void RequireDelegate&lt;T>(T param) where T: Delegate
            {
                throw new NotImplementedException();
            }
    
            static void RequireUnmanaged&lt;T>(T param) where T: unmanaged
            {
                throw new NotImplementedException();
            }
          </code></pre>
      </section>

      <section>
        <section>
          <h1>Lecimy tutaj</h1>
        </section>
        <section>
          <h2>Backing-fields attributes</h2>

          <pre><code class="cs" data-trim data-noescape>
            [<span class="fragment highlight-mark">field:</span> SomeThingAboutFieldAttribute]
            public int SomeProperty { get; set; }
          </code></pre>
        </section>

        <section>
          <h2>Ref local reassignment</h2>

          <pre><code class="cs" data-trim data-noescape>
            var evenNumbers = new MyArray(2, 4, 6, 8, 10);
            ref var number = ref evenNumbers[2];
            <span class="fragment highlight-mark">number = ref evenNumbers[1];</span>
          </code></pre>
        </section>

        <section>
          <h2><i>Stackalloc</i> arrays support initializers</h2>

          <pre><code class="cs" data-trim data-noescape>
            int* pArr = stackalloc int[3] <span class="fragment highlight-mark" data-fragment-index="1">{1, 2, 3}</span>;
            int* pArr2 = stackalloc int[] <span class="fragment highlight-mark" data-fragment-index="1">{1, 2, 3}</span>;
            Span&lt;int> arr = stackalloc [] <span class="fragment highlight-mark" data-fragment-index="1">{1, 2, 3}</span>;
          </code></pre>
        </section>
      </section>

      <section>
        <section>
          <h1>Co na horyzoncie? C# 8</h1>

          <aside class="notes">
            <a href="https://blogs.msdn.microsoft.com/dotnet/2018/11/12/building-c-8-0/">
              https://blogs.msdn.microsoft.com/dotnet/2018/11/12/building-c-8-0/</a>
          </aside>
        </section>

        <section>
          <h2>Nullable reference types</h2>

          <span class="fragment fade-in">
            <pre><code class="cs" data-trim data-noescape>
            string s = null; // Warning: Assignment of null to non-nullable reference type
          </code></pre>
          </span>

          <span class="fragment fade-in">
            <pre><code class="cs" data-trim data-noescape>
              string? s = null; // Ok
            </code></pre>
          </span>

          <span class="fragment fade-in">
            <pre><code class="cs" data-trim data-noescape>
              void M(string? s)
              {
                  Console.WriteLine(s.Length); // Warning: Possible null reference exception
                  if (s != null)
                  {
                      Console.WriteLine(s.Length); // Ok: You won't get here if s is null
                  }
              }
          </code></pre>
          </span>
        </section>

        <section>
          <h2>Async streams</h2>

          <pre><code class="cs" data-trim data-noescape>
            async IAsyncEnumerable<int> GetBigResultsAsync()
            {
                await foreach (var result in GetResultsAsync())
                {
                    if (result > 20) yield return result; 
                }
            }
          </code></pre>
        </section>

        <section>
          <h2>Ranges and indeces</h2>

          <pre><code class="cs" data-trim data-noescape>
              <span class="fragment highlight-mark" data-fragment-index="1">Index</span> i1 = 3;  // number 3 from beginning
              <span class="fragment highlight-mark" data-fragment-index="1">Index</span> i2 = <span class="fragment highlight-mark" data-fragment-index="1">^</span>4; // number 4 from end
              int[] a = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
              Console.WriteLine($"{a[i1]}, {a[i2]}"); // "3, 6"
          </code></pre>

          <span class="fragment fade-in" data-fragment-index="2">
            <pre><code class="cs" data-trim data-noescape>
              var slice = a[i1<span class="fragment highlight-mark" data-fragment-index="3">..</span>i2]; // { 3, 4, 5 }
            </code></pre>
          </span>
        </section>

        <section>
          <h2>Default implementations of interface members</h2>

          <pre><code class="cs" data-trim data-noescape>
            interface ILogger
            {
                void Log(LogLevel level, string message);
                void Log(Exception ex) <span class="fragment highlight-mark">=> Log(LogLevel.Error, ex.ToString());</span> // New overload
            }
            
            class ConsoleLogger : ILogger
            {
                public void Log(LogLevel level, string message) { ... }
                // Log(Exception) gets default implementation
            }
          </code></pre>
        </section>

        <section>
          <h2>Recursive patterns</h2>

          <pre><code class="cs" data-trim data-noescape>
            IEnumerable&lt;string> GetEnrollees()
            {
                foreach (var p in People)
                {
                    if (p is Student { Graduated: false, Name: string name }) yield return name;
                }
            }
          </code></pre>
        </section>

        <section>
          <h2>Switch expressions</h2>

          <pre><code class="cs" data-trim data-noescape>
            var area = figure switch 
            {
                Line _      => 0,
                Rectangle r => r.Width * r.Height,
                Circle c    => Math.PI * c.Radius * c.Radius,
                _           => throw new UnknownFigureException(figure)
            };
          </code></pre>
        </section>

        <section>
          <h2>Target-typed new-expressions</h2>

          <pre><code class="cs" data-trim data-noescape>
            Point[] ps = { new (1, 4), new (3,-2), new (9, 5) }; // all Points
          </code></pre>
        </section>
      </section>

      <section>
        <h1>Podsumowanie</h1>

        <ul>
          <li class="fragment fade-in">Fajnie je</li>
          <li class="fragment fade-in">Będzie jeszcze fajniej</li>
          <li class="fragment fade-in">C# to je moje ulubiene</li>
        </ul>
      </section>
      <section>
        <h2>Materiały</h2>

        <ul>
          <li>
            Microsoft Documentation
            <ul>
              <li>
                <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7">
                  What's new in C# 7
                </a>
              </li>
              <li><a href="https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-1">
                  What's new in C# 7.1
                </a>
              </li>
              <li><a href="https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-2">
                  What's new in C# 7.2
                </a>
              </li>
              <li><a href="https://docs.microsoft.com/pl-pl/dotnet/csharp/whats-new/csharp-7-3">
                  What's new in C# 7.3
                </a>
              </li>
            </ul>
          </li>
          <li>
            <a href="https://blogs.msdn.microsoft.com/dotnet/2018/11/12/building-c-8-0/">
              Zapowiedź C# 8
            </a>
          </li>
          <li>
            <a href="https://github.com/Eragra3/whats-new-in-CSharp">Przentacja na GitHubie</a>
          </li>
          <li>
            <a href="https://sharplab.io/">SharpLab</a>
          </li>
        </ul>
      </section>
      <section>
        <h2>Pytania</h2>
      </section>

    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        {
          src: 'plugin/highlight/highlight.js',
          async: true,
          callback: function () {
            hljs.initHighlightingOnLoad();
          }
        },
        { src: 'node_modules/reveal.js-menu/menu.js' }
      ],
      menu: {
        numbers: true,
        themes: true,
        loadIcons: false
      },
      width: '100%',
      height: '100%',
      defaultTiming: 60
    });
  </script>
</body>

</html>
