<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/custom.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/dracula.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU"
        crossorigin="anonymous">
</head>

<body>
    <div class="reveal">
        <div class="slides">

            <section>
                <h2>Nowości w języku
                    <span class="fragment strike">Cool</span>
                    <span class="fragment fade-in">C#</span>
                </h2>
                <p class="fragment fade-in-and-out">C-like Object Oriented Language</p>

                <h3>
                    Daniel Bider
                </h3>

                <aside class="notes">
                    <p>Biblioteka napisana w Simple Managed C (SMC), potem sportowana do C#</p>>
                </aside>
            </section>

            <section>
                <h2>Krótka historia C#</h2>
                <span class="fragment fade-in">Rok powstania: </span>
                <span class="fragment fade-in">1999</span>
                <br \>
                <span class="fragment fade-in">Twórca: </span>
                <span class="fragment fade-in">Anders Hejlsberg</span>

                <aside class="notes">
                    <p>Java - 1995, Ryan Gosling</p>
                    <p>C++ - 1985, Bjarne Stroustrup</p>
                </aside>
            </section>

            <section>
                <h2>Wersje C#</h2>

                <div class="fragment fade-in">
                    <h3>C# 1.0 (1.1, 1.2)</h3>
                    <p class="fragment fade-in">nic ciekawego</p>
                </div>

                <aside class="notes">
                    <p>brak generyków, nie ma LINQ, kalka Javy (twórcy twierdzą, że nie kalka)</p>
                </aside>
            </section>

            <section>
                <h3>C# 2.0</h3>
                <ul class="fragment fade-in">
                    <li>Generics</li>
                    <li>Nullable types</li>
                    <li>Partial types</li>
                    <li>Static classes</li>
                    <li>Variance</li>
                </ul>
            </section>

            <section>
                <h3>C# 3.0</h3>
                <ul class="fragment fade-in">
                    <li>Var keyword</li>
                    <li>Lambdas</li>
                    <li>Object and collection initializers</li>
                    <li>Auto-properties</li>
                    <li>Extension methods</li>
                    <li>Partial methods</li>
                </ul>
            </section>

            <section>
                <h3>C# 4.0</h3>
                <ul class="fragment fade-in">
                    <li>Dynamic binding...</li>
                    <li>Generic variance</li>
                </ul>
            </section>

            <section>
                <h3>C# 5.0</h3>
                <ul class="fragment fade-in">
                    <li>Async</li>
                </ul>
            </section>

            <section>
                <h3>C# 6.0</h3>
                <ul class="fragment fade-in">
                    <li><b>Compiler-as-a-service (Roslyn)</b></li>
                    <li>Auto property initializers</li>
                    <li>String interpolation</li>
                    <li>Nameof operator</li>
                    <li>Exception filters</li>
                    <li>Null propagator</li>
                    <li>Dictionary initializer</li>
                </ul>

                <aside class="notes">
                    <p>C#6 <a href="https://github.com/dotnet/roslyn/wiki/Languages-features-in-C%23-6-and-VB-14"></a></p>
                </aside>
            </section>

            <section>
                <h1>C# 7.0</h1>
            </section>
            <section>

                <section>
                    <h2>Inline out variables</h2>

                    <pre><code class="C#" data-trim data-noescape>
                        string numberString = "42";

                        <mark>int number;</mark>
                        if (int.TryParse(numberString, <mark>out number</mark>))
                        {
                            int nextNumber = number + 1;
                        (...)
                    </code></pre>

                    <span class="fragment fade-in">
                        <i class="fas fa-long-arrow-alt-down"></i>

                        <pre><code class="C#" data-trim data-noescape>
                            string numberString = "42";
        
                            if (int.TryParse(numberString, <mark>out int number</mark>))
                            {
                                int nextNumber = number + 1;
                            (...)
                        </code></pre>
                    </span>
                </section>

                <section>
                    <h2>IL</h2>
                    <pre><code class="C#" data-trim data-noescape>
                        IL_0007: ldloc.0
                        IL_0008: ldloca.s 1
                        IL_000a: call bool [mscorlib]System.Int32::TryParse(string, int32&)
                        IL_000f: stloc.2
                        // sequence point: hidden
                        IL_0010: ldloc.2
                        IL_0011: brfalse.s IL_0031
                    </code></pre>

                    <span class="fragment fade-in">
                        <i class="fas fa-long-arrow-alt-down"></i>
                        <pre><code class="C#" data-trim data-noescape>
                            IL_0007: ldloc.0
                            IL_0008: ldloca.s 1
                            IL_000a: call bool [mscorlib]System.Int32::TryParse(string, int32&)
                            IL_000f: stloc.2
                            // sequence point: hidden
                            IL_0010: ldloc.2
                            IL_0011: brfalse.s IL_0031
                        </code></pre>
                    </span>
                </section>

                <section>
                    <h2>Uwaga na scope zmiennej!</h2>

                    <pre><code class="C#" data-trim data-noescape>
                            static void Main(string[] args)
                            {
                                string numberString = "42";
                                for (int i = 0; i < 100; i++)
                                {
                                    if (int.TryParse(numberString, out int number))
                                    {
                                        int nextNumber = number + 1;
                                        Console.WriteLine($"Next person number is {nextNumber}");
                                    }
                                    else
                                    {
                                        Console.WriteLine("Invalid number");
                                    }
                                }
                            }
                        </code></pre>
                </section>

                <section>
                    <h2>Uwaga na scope zmiennej!</h2>

                    <pre><code class="C#" data-trim data-noescape>
                            static void Main(string[] args)
                            {
                                string numberString = "42";
                                for (int i = 0; i < 100; i++)<mark>
                                {
                                    if (int.TryParse(numberString, out int number))
                                    {
                                        int nextNumber = number + 1;
                                        Console.WriteLine($"Next person number is {nextNumber}");
                                    }
                                    else
                                    {
                                        Console.WriteLine("Invalid number");
                                    }
                                }</mark>
                            }
                        </code></pre>
                </section>
            </section>

            <section>
                <section>
                    <h2>Krotki (tuples)</h2>

                    <pre><code class="C#" data-trim data-noescape>
                        var t1 = new Tuple&lt;int, double, int&gt;(-3, 10.0, 4);
                    </code></pre>

                    <span class="fragment fade-in">
                        <i class="fas fa-long-arrow-alt-down"></i>

                        <pre><code class="C#" data-trim data-noescape>
                            var t1 = (-3, 10.0, 4);
                        </code></pre>
                    </span>
                </section>
                <section>
                    <h2>Nazwane krotki</h2>

                    <pre><code class="C#" data-trim data-noescape>
                        var t1 = (min: -3, avg: 10.0, max: 4);
                        Console.WriteLine(t1.min);
                    </code></pre>
                </section>

                <section>
                    <h2>Dekonstrukcja</h2>

                    <pre><code class="C#" data-trim data-noescape>
                            var minAvgMax = (min: -3, avg: 10.0, max: 4);
                            var (min, avg, max) = minAvgMax;
                            Console.WriteLine(min);
                    </code></pre>

                    <aside class="notes">
                        Przykład
                    </aside>
                </section>
            </section>

            <section>
                <section>
                    <h2>Pattern matching</h2>

                    <aside class="notes">
                        <a href="https://docs.microsoft.com/en-gb/dotnet/csharp/pattern-matching"></a>
                    </aside>
                </section>
                <section>
                    <h2>"Is" pattern</h2>

                    <pre><code class="C#" data-trim data-noescape>
                        if (p <mark>is Student</mark>)
                        {
                            <mark>var s = (Student) p;</mark>
                            Console.WriteLine($"Index: {s.Index}");
                        }
                    </code></pre>

                    <span class="fragment fade-in">
                        <i class="fas fa-long-arrow-alt-down"></i>

                        <pre><code class="C#" data-trim data-noescape>
                            if (p <mark>is Student s</mark>)
                            {
                                Console.WriteLine($"Index: {s.Index}");
                            }
                        </code></pre>
                    </span>


                    <aside class="notes">
                        Uwaga na ifologię, prawdopodobnie lepiej stworzyć dodatkowy interfejs
                        IInfoPrinter i zrzucić odpowiedzialność przedstawiania się na klasy.
                        Zaproponowane rozwiązanie jest podejściem funkcyjnym.
                    </aside>
                </section>

                <section>
                    <h2>IL</h2>

                    <div class="container-inline">
                        <pre><code class="C#" data-trim data-noescape>
                        IL_0001: ldarg.0
                        IL_0002: isinst OutVariables.Student
                        IL_0007: ldnull
                        IL_0008: cgt.un
                        IL_000a: stloc.0
                        // sequence point: hidden
                        IL_000b: ldloc.0
                        IL_000c: brfalse.s IL_002d
                    
                        IL_000e: nop
                        IL_000f: ldarg.0
                        <span class="fragment highlight-red" data-fragment-index="1">IL_0010: castclass OutVariables.Student</span>
                        IL_0015: stloc.1
                    </code></pre>

                        <span class="fragment fade-in">
                            <i class="fas fa-long-arrow-alt-down"></i>
                            <pre><code class="C#" data-trim data-noescape>
                            IL_0001: ldarg.0
                            IL_0002: isinst OutVariables.Student
                            IL_0007: dup
                            IL_0008: stloc.0
                            IL_0009: ldnull
                            IL_000a: cgt.un
                            IL_000c: stloc.1
                            // sequence point: hidden
                            IL_000d: ldloc.1
                            IL_000e: brfalse.s IL_0028
                        </code></pre>
                        </span>
                    </div>
                </section>

                <section>
                    <h2>Liskov is SOLID</h2>

                    <ul>
                        <li class="fragment fade-in">Metoda musi znać wszystkie klasy rozszerzające klasę Person</li>
                        <li class="fragment fade-in">Dodanie nowej klasy dziedziczącej zepsuje kod</li>
                        <li class="fragment fade-in">Łamiemy enkapsulację</li>
                    </ul>
                </section>
                <section>
                    <h2>Uwaga na scope zmiennej!</h2>

                    <pre><code class="C#" data-trim data-noescape>
                        static void OldPrintInfo(Person p)
                        {
                            Console.WriteLine($"FirstName: {p.FirstName}");
                            Console.WriteLine($"LastName: {p.LastName}");
                
                            if (p is Student s)<span class="fragment highlight-mark">
                            {
                                Console.WriteLine($"Index: {s.Index}");
                            }</span>
                            else if (p is Programmer)
                            {
                                var pr = (Programmer) p;
                                Console.WriteLine($"CSharp: {pr.CSharp}");
                                Console.WriteLine($"Java: {pr.Java}");
                            }
                        }
                        </code></pre>
                </section>
                <section>
                    <h2>Co jest nie tak z "safe castem"</h2>

                    <pre><code class="C#" data-trim data-noescape>
                        static void SafeCast()
                        {
                            object numbers = Enumerable.Range(-3, 10).ToArray();
                
                            foreach (var number in <span class="fragment highlight-mark" data-fragment-index="1">numbers as IEnumerable&lt;int&gt;</span>) <span class="fragment fade-in" style="color: red" data-fragment-index="1">NullPointerException</span>
                            {
                                Console.WriteLine(number);
                            }
                        }
                    </code></pre>

                </section>
                <section>
                    <h2>Co jest nie tak z "safe castem"</h2>

                    <pre><code class="C#" data-trim data-noescape>
                        private static void SafeCast()
                            {
                                object obj = Enumerable.Range(-3, 10).ToArray();
                                IEnumerator<int> enumerator = <span class="fragment highlight-mark">(obj as IEnumerable<int>).GetEnumerator()</span>;
                                try
                                {
                                    while (enumerator.MoveNext())
                                    {
                                        int current = enumerator.Current;
                                        Console.WriteLine(current);
                                    }
                                }
                                finally
                                {
                                    if (enumerator != null)
                                    {
                                        enumerator.Dispose();
                                    }
                                }
                            }
                    </code></pre>
                </section>
            </section>
            <section>
                Discards

                <aside class="notes">
                    <a href="https://docs.microsoft.com/en-gb/dotnet/csharp/discards"></a>
                </aside>
            </section>
            <section>Funkcje lokalne</section>
            <section>Praktyczny przykład</section>
            <section>Ref local/return</section>
            <section>Expression-bodied members</section>
            <section>Pułapki wyrażenia "throw"</section>
            <section>Wincyj "asynców"</section>
            <section>Nowe wyrażenia literałów</section>
            <section>C# 7.1</section>
            <section>Ulepszonko pattern matchingu</section>
            <section>Praktyczny przykład</section>
            <section>Aync main</section>
            <section>Inicjalizacja domyślną wartością</section>
            <section>Domyślne nazwy elementów krotek</section>
            <section>C# 7.2</section>
            <section>In parameters</section>
            <section>Praktyczny przykład</section>
            <section>Ref struct widmo</section>
            <section>Span</section>
            <section>Memory</section>
            <section>Ref readonly</section>
            <section>Readonly struct</section>
            <section>Non-trailing named arguments</section>
            <section>Private protected</section>
            <section>C# 7.3</section>
            <section>Dodatkowe ograniczenia typów (w końcu!)</section>
            <section>Ref local reassignment</section>
            <section>Tuples equality</section>
            <section>Backing-fields attributes</section>
            <section>Co na horyzoncie? C# 8</section>
            <section>Jeszcze bardziej rozbudowany pattern-matching i dekonstrukcja</section>
            <section>Nullable reference types</section>
            <section>Record classes</section>
            <section>Domyślne implementacje interfejsów</section>
            <section>Async streams</section>
            <section>Ranges</section>
            <section>Genericzne atrybuty</section>
            <section>Target-typed new</section>
            <section>Podsumowanie</section>
            <section>Pytania</section>

        </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
        // More info about config & dependencies:
        // - https://github.com/hakimel/reveal.js#configuration
        // - https://github.com/hakimel/reveal.js#dependencies
        Reveal.initialize({
            dependencies: [
                { src: 'plugin/markdown/marked.js' },
                { src: 'plugin/markdown/markdown.js' },
                { src: 'plugin/notes/notes.js', async: true },
                {
                    src: 'plugin/highlight/highlight.js',
                    async: true,
                    callback: function () {
                        hljs.initHighlightingOnLoad();
                    }
                },
                { src: 'node_modules/reveal.js-menu/menu.js' }
            ],
            menu: {
                numbers: true,
                themes: true,
                loadIcons: false
            },
            width: '100%',
            height: '100%'
        });
    </script>
</body>

</html>